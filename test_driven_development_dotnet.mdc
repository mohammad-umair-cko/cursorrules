---
name: test_driven_development_dotnet
description: Standards for Test-Driven Development (TDD) in ASP.NET Core projects
date: 2025-04-21
globs:
  - "src/**/*.cs"
  - "tests/**/*.cs"
tags:
  - testing
  - tdd
  - unit-tests
  - services
  - specs
alwaysApply: true
---

## ðŸ§ª Test-Driven Development (TDD) in ASP.NET Core

This rule enforces TDD practices in ASP.NET Core projects by promoting test-first development, behavior-driven specs, and code coverage of all scenarios.

---

## ðŸ” Core Principles

1. **Test First, Code Second**
   - Always check for existing tests before writing new code.
   - Create tests BEFORE writing or updating the implementation.
   - Use tests to define expected behavior and constraints.

2. **Red â†’ Green â†’ Refactor**
   - ðŸ”´ Write a failing test
   - ðŸŸ¢ Write the simplest code to pass it
   - ðŸ›  Refactor both code and tests for clarity, keeping them green

3. **Tests Are Documentation**
   - Good tests describe **what** a system does, **not how**
   - Include edge cases and error handling
   - Describe scenarios using clear naming conventions
   - Don't use Mocks (except for things we don't own like HttpClient, DBs, etc). Rather use Fake or InMemory implementations.

---

## âœ… Validation Checklist

Before writing or reviewing production code:

- [ ] Spec/test class exists in `tests/` mirroring the structure of `src/`
- [ ] All public methods are covered with unit
- [ ] Edge cases and invalid inputs are handled
- [ ] Tests fail before implementation, pass after
- [ ] Tests are isolated, repeatable, and assert meaningful behavior
- [ ] No implementation-only commits â€” always pair with tests
- [ ] Once done with implementation add integration tests for critical path

---

## ðŸ§° Common Test Patterns

### âœ… Service Tests
```csharp
public class EmailSenderTests
{
    [Fact]
    public void Send_WithValidInput_ReturnsSuccess()
    {
        var sender = new EmailSender();
        var result = sender.Send("test@example.com", "Hello");

        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public void Send_WithEmptyEmail_ReturnsFailure()
    {
        var sender = new EmailSender();
        var result = sender.Send("", "Hello");

        result.IsSuccess.Should().BeFalse();
        result.ErrorMessage.Should().Be("Email is required");
    }
}
```

### âœ… Model Validation (with FluentValidation)
```csharp
public class UserValidatorTests
{
    [Fact]
    public void Validate_MissingEmail_ReturnsValidationError()
    {
        var validator = new UserValidator();
        var result = validator.Validate(new User());

        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contains(e => e.PropertyName == "Email");
    }

    [Fact]
    public void Validate_ValidUser_PassesValidation()
    {
        var validator = new UserValidator();
        var user = new User { Email = "valid@example.com" };

        var result = validator.Validate(user);

        result.IsValid.Should().BeTrue();
    }
}
```

### âœ… Controller Tests (with WebApplicationFactory)
```csharp
public class UsersControllerTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;

    public UsersControllerTests(WebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task GetUser_Returns200AndUserData()
    {
        var response = await _client.GetAsync("/api/users/1");

        response.EnsureSuccessStatusCode();
        var content = await response.Content.ReadAsStringAsync();

        content.Should().Contains("username");
    }

    [Fact]
    public async Task GetUser_NotFound_Returns404()
    {
        var response = await _client.GetAsync("/api/users/9999");

        response.StatusCode.Should().Be(HttpStatusCode.NotFound);
    }
}
```

---

## â›” What Not To Do

### ðŸš« No tests
```csharp
public class InvoiceService
{
    public Invoice Generate(decimal amount)
    {
        return new Invoice { Total = amount }; // Created without any test coverage
    }
}
```

### ðŸš« Over-mocking internal logic
```csharp
var mockService = new Mock<InvoiceService>();
mockService.Setup(x => x.Generate(It.IsAny<decimal>())).Returns(new Invoice());
// Avoid mocking logic under your control
```

### ðŸš« Testing implementation details
```csharp
// Bad: tightly coupled to private field
Assert.Equal("abc123", invoiceService._token);
```

---

## ðŸ§  Best Practices

- ðŸ”¹ One test class per implementation class
- ðŸ”¹ Group related tests with `#region` or nested classes
- ðŸ”¹ Use clear naming: `Scenario`. Avoid tieing it to code. Keep it short.
- ðŸ”¹ Prefer real objects; mock only what you donâ€™t own (e.g., HTTP clients, DBs)
- ðŸ”¹ Keep tests deterministic and isolated
- ðŸ”¹ Match test folder structure with `src/` structure
- ðŸ”¹ Use [FluentAssertions](https://fluentassertions.com/) for expressive assertions
- ðŸ”¹ Use `[Theory]` and `[InlineData]` to cover multiple cases efficiently

---

## ðŸ“‹ Enforcement

The assistant should:

1. âœ… Ensure a matching test file exists in `tests/` for each file in `src/`
2. âœ… Block merging untested logic unless explicitly excluded (e.g., DTOs)
3. âœ… Recommend tests for uncovered methods or paths
4. âœ… Suggest descriptive test names and assertions for behavior
5. âœ… Flag implementation-only commits without any corresponding test update
6. âœ… Point to appropriate test pattern examples in this rule

---

## ðŸ“š References

- [xUnit Documentation](https://xunit.net/)
- [FluentAssertions](https://fluentassertions.com/)
- [ASP.NET Core Testing](https://learn.microsoft.com/en-us/aspnet/core/test/)
- [Microsoft Unit Testing Best Practices](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices)
- [Cursor Rule Authoring Docs](https://docs.cursor.com/context/rules)
